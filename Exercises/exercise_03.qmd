---
title: "Exercise 03"
order: 3
status: Completed
date-due: 2023-09-18
date-modified	: 2023-09-17
---

::: {.callout-important appearance="minimal" icon="true"}
Exercise due on {{< meta date-due >}}
:::

ℹ️ See [week
{{< meta order >}}](https://bldgspatialdata.github.io/website/weeks/week_0%7B%7B%3C%20meta%20order%20%3E%7D%7D.html) for related slides and readings

## Overview

This week's exercise comes directly from [the data transformation
chapter](https://r4ds.hadley.nz/data-transform) of R for Data Science.
More typically, our exercises will always include spatial data but I
wanted to use a more tried and tested exercise for this week's material.

## Setup

If you don't already have the `{nycflights13}` package installed, go ahead and install it then restart before continuing with the exercise.

```{r}
#| eval: false
pak::pkg_install("nycflights13")
```

In addition to nycflights13, you will also need `{dplyr}` and `{ggplot2}`. Load the tidyverse library to make sure you have everything you need:

```{r}
library(nycflights13)
library(tidyverse)
```

## Exercises

### Working with rows

In a single pipeline for each condition, find all flights that meet the
condition:

-   Had an arrival delay of two or more hours
-   Flew to Houston (`IAH` or `HOU`)
-   Were operated by United, American, or Delta
-   Departed in summer (July, August, and September)
-   Arrived more than two hours late, but didn't leave late
-   Were delayed by at least an hour, but made up over 30 minutes in
    flight

```{r}
flights |> 
  filter(arr_delay >= 120) 
```

```{r}
flights |>
  filter(dest == "IAH" | dest == "HOU") 
```

```{r}
flights |>
  filter(carrier == "UA" | carrier == "AA" | carrier == "DL") 
```

```{r}
flights |>
  filter(month %in% c(7,8,9)) 
```

```{r}
flights |>
  filter(arr_delay > 120 & dep_delay == 0) 
```

```{r}
flights |>
  filter(dep_delay >= 60 & arr_delay <= (dep_delay - 30))
```

Sort `flights` to find the flights with longest departure delays. Find
the flights that left earliest in the morning.

```{r}
flights |> 
  arrange(desc(dep_delay))
```
```{r}
flights |>
  arrange(dep_time) 
```

Sort `flights` to find the fastest flights. (Hint: Try including a math
calculation inside of your function.)

```{r}
flights |> 
  mutate(
    .speed = (distance / air_time),
    .before = dep_time
  ) |>
  arrange(-.speed)
```

Was there a flight on every day of 2013?
Yes - There were flights on all the days of 2013.
```{r}
flights |> 
  summarize(
    n_days = n_distinct(day),
    .by = month
  ) |>
  arrange(month)
```
```{r}
flights |>
  distinct(month, day) #There are 365 distinct dates
```


Which flights traveled the farthest distance? Which traveled the least
distance?

```{r}
flights |> 
  filter(
    distance == max(distance)
  )
flights |> 
  filter(    
    distance == min(distance)
  )
```

Does it matter what order you used
[`filter()`](https://dplyr.tidyverse.org/reference/filter.html) and
[`arrange()`](https://dplyr.tidyverse.org/reference/arrange.html) if
you're using both? Why/why not? Think about the results and how much
work the functions would have to do.

Using filter() before arrange() is efficient as only the rows left after applying the conditions have to be sorted. This decreases the run time for the functions than when used in the reverse order. 

### Working with columns

Compare `dep_time`, `sched_dep_time`, and `dep_delay`. How would you
expect those three numbers to be related?

dep_delay = dep_time - sched_dep_time

Brainstorm as many ways as possible to select `dep_time`, `dep_delay`,
`arr_time`, and `arr_delay` from `flights`.

```{r}
select(flights, dep_time, dep_delay, arr_time, arr_delay)
select(flights, c(dep_time, dep_delay, arr_time, arr_delay))
select(flights, all_of(c("dep_time", "dep_delay", "arr_time", "arr_delay")))
select(flights,c(starts_with("dep"), starts_with("arr")))
select(flights, any_of(c("dep_time", "dep_delay", "arr_time", "arr_delay")))
```

What happens if you specify the name of the same variable multiple times
in a [`select()`](https://dplyr.tidyverse.org/reference/select.html)
call?
It is displayed only once!
```{r}
select(flights, dep_time, dep_time)
```

What does the
[`any_of()`](https://tidyselect.r-lib.org/reference/all_of.html)
function do? Why might it be helpful in conjunction with this vector?
It is help function that allows us to guess the right variable names. It does not throw an error when incorrect variables are passed in a select() function.
```{r}
variables <- c("year", "month", "day", "dep_delay", "arr_delay")
select(flights, any_of(variables))
```

Does the result of running the following code surprise you? How do the
select helpers deal with upper and lower case by default? How can you
change that default?
contains() helper select the variables which matches the literal string passed and is case-insensitive. It can be made case-sensitive by setting ignore.case = FALSE
```{r}
flights |> select(contains("TIME"))
```
```{r}
flights |> select(contains("TIME", ignore.case = FALSE))
```

Rename `air_time` to `air_time_min` to indicate units of measurement and
move it to the beginning of the data frame.

```{r}
flights |> 
  rename(air_time_min = air_time) |>
  select(air_time_min, everything())
```

Why doesn't the following work, and what does the error mean?
The sorting function(arrange()) has to be completed before selecting the column

```{r}
flights |> 
  select(tailnum) |> 
  arrange(arr_delay)
```

```{r}
flights |>
  arrange(arr_delay) |>
  select(tailnum)
```

### Working with groups

Which carrier has the worst average delays? Challenge: can you
disentangle the effects of bad airports vs. bad carriers? Why/why not?
(Hint: think about
`flights |> group_by(carrier, dest) |> summarize(n())`)
```{r}
flights |>
  group_by(carrier) |>
  summarise(
    avg_dep_delays = mean(dep_delay, na.rm = TRUE),
    avg_arr_delays = mean(arr_delay, na.rm = TRUE),
  ) |>
  arrange(desc(avg_dep_delays))
```

```{r}
flights |> 
  group_by(carrier, dest) |>
  summarize(
    avg_dep_delays = mean(dep_delay, na.rm = TRUE),
    avg_arr_delays = mean(arr_delay, na.rm = TRUE),
    n_rows = n()
  ) |>
  arrange(desc(avg_dep_delays))
```
From the above data frame, we can understand that te avg_delays are entangled with the carrier and destinations. We can retrieve the impact of carrier and destination by separate analysis on each of them - grouping one variable at a time.


Find the flights that are most delayed upon departure from each
destination.

```{r}
flights |>
  group_by(dest) |>
  slice_max(dep_delay, n = 1) |>
  relocate(dest)
```

How do delays vary over the course of the day. Illustrate your answer
with a plot.

```{r}
library(ggplot2)
flights |>
  ggplot() +
  geom_point(aes(dep_time, dep_delay)) 
```

What happens if you supply a negative `n` to [`slice_min()`](https://dplyr.tidyverse.org/reference/slice.html) and
friends? It gives the whole data frame arrranged in ascending order of the variable, here arr_delay.

```{r}
slice_min(flights, arr_delay, n = -1)
```

Explain what [`count()`](https://dplyr.tidyverse.org/reference/count.html) does in
terms of the dplyr verbs you just learned. 
count() functions gives the number of times the variable, here, dest, occurs in the data frame.
What does the `sort` argument to [`count()`](https://dplyr.tidyverse.org/reference/count.html) do?
sort = TRUE gives the number of each destination in descending order
```{r}
count(flights, dest)

count(flights, dest, sort = TRUE)
```
